#!/usr/bin/env ruby

require 'pomodoro'
require 'refined-refinements/colours'

using RR::ColourExts

def parse_today_list(config)
  list = Pomodoro::Formats::Today.parse(File.new(config.today_path, encoding: 'utf-8'))

  if (active_tasks = list.each_task.select(&:in_progress?)).length > 1
    raise "There are 2 active tasks: #{active_tasks}"
  end

  list
end

def parse_task_list(config)
  Pomodoro::Formats::Scheduled.parse(File.new(config.task_list_path, encoding: 'utf-8'))
end

def time_frame(config, &block)
  today_list = parse_today_list(config)

  unless current_time_frame = today_list.current_time_frame
    abort "<red>There is no active time frame.</red>".colourise
  end

  block.call(today_list, current_time_frame)
end

def with_active_task(config, &block)
  today_list = parse_today_list(config)
  if active_task = today_list.active_task
    block.call(active_task)
    today_list.save(config.today_path)
  end
end

def edit_next_task_when_no_task_active(config, &block)
  time_frame(config) do |today_list, current_time_frame|
    if active_task = today_list.active_task
      abort "<red>There is an active task already:</red> #{active_task.body}".colourise
    end

    if next_task = current_time_frame.first_unstarted_task
      block.call(next_task)
      today_list.save(config.today_path)
    else
      abort "<red>No more tasks in #{current_time_frame.name}</red>".colourise
    end
  end
end

def generate_todays_tasks(date, config)
  require 'pomodoro/scheduler'

  date_path = config.today_path(date)

  return date_path if File.exist?(config.today_path(date))

  scheduler = Pomodoro::Scheduler.load([config.schedule_path, config.routine_path], date)

  schedule = scheduler.schedule_for_date(date)
  task_list = schedule.call

  if task_list.time_frames.empty?
    abort "<red>No time frames were found in the task list.</red>".colourise
  end

  scheduler.populate_from_rules(task_list)

  scheduled_task_list = parse_task_list(config)

  scheduled_task_list.each do |task_group|
    if task_group.scheduled_date == date
      task_group.tasks.each do |task|
        puts "~ #{task}"
        task_list.time_frames.first.create_task(task)
        scheduled_task_list.delete(task_group)
      end
    end
  end

  task_list.save(date_path)
  scheduled_task_list.save(config.task_list_path)

  return date_path
end

# Main.
config = Pomodoro::Config.new

case ARGV.shift
when 'edit', 'e'
  if ARGV.empty?
    date_path = generate_todays_tasks(Date.today, config)
    exec("vim #{date_path}")
  elsif ARGV.first.to_i == 2
    date_path = generate_todays_tasks(Date.today, config)
    exec("vim -O2 #{date_path} #{config.task_list_path}")
  elsif ARGV.first == 'tomorrow'
    date_path = generate_todays_tasks(Date.today + 1, config)
    exec("vim -O2 #{date_path} #{config.task_list_path}")
  elsif ['tasks', 't'].include?(ARGV.first)
    exec("vim #{config.task_list_path}")
  else
    abort(DATA.read.colourise)
  end
when 'start'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  with_active_task(config) do |active_task|
    abort "<red>There is an active task already:</red> #{active_task.body}".colourise
  end

  edit_next_task_when_no_task_active(config) do |next_task|
    puts "<bold>~</bold> <green>#{next_task.body}</green> has been started.".colourise
    next_task.start!
  end
when 'next'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  with_active_task(config) do |active_task|
    abort "<red>There is an active task already:</red> #{active_task.body}".colourise
  end

  time_frame(config) do |today_list, current_time_frame|
    if next_task = current_time_frame.first_unstarted_task
      puts "<bold>~</bold> <green>#{next_task.body}</green>".colourise
    else
      abort "<red>No more tasks in #{current_time_frame.desc}</red>".colourise
    end
  end
when 'done'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  with_active_task(config) do |active_task|
    active_task.complete!
    puts "<bold>~</bold> <green>#{active_task.body}</green> has been finished.".colourise
  end
when 'postpone'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  print "<bold>Why?</bold> ".colourise
  reason = STDIN.readline.chomp
  print "<bold>When do you want to review?</bold> Defaults to tomorrow. ".colourise
  review_at = STDIN.readline.chomp

  # Ask for metadata and comments.
  with_active_task(config) do |active_task|
    review_at.empty? ? active_task.postpone!(reason) : active_task.postpone!(reason, review_at)
    puts "<bold>~</bold> <green>#{active_task.body}</green> has been postponed.".colourise
  end
when 'move_on'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  # Ask for metadata and comments.
  with_active_task(config) do |active_task|
    active_task.move_on!
    puts "<bold>~</bold> You moved on from <green>#{active_task.body}</green>.".colourise
  end
when 'active'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  today_list = parse_today_list(config)
  if  active_task = today_list.active_task
    case ARGV.shift
     # git-commit-pomodoro
     # TODO: Subtasks as well.
    when 'git'    then puts active_task.text
    when 'prompt' then puts active_task.text
    when nil      then puts active_task
    else
      puts 'xxx'
      # TODO: Format with %d etc.
    end
  else
    abort "<red>No active tasks.</red>".colourise
  end
when 'tick-off-next'
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  edit_next_task_when_no_task_active(config) do |next_task|
    next_task.complete!
    puts "<bold>~</bold> <green>#{next_task.body}</green> has been finished.".colourise
  end
when 'fail-next'
  # Before we start asking, so we cannot wait for the exception.
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  print "<bold>Why?</bold> ".colourise
  reason = STDIN.readline.chomp
  edit_next_task_when_no_task_active(config) do |next_task|
    next_task.fail!(reason)
    puts "<bold>~</bold> <green>#{next_task.body}</green> has been failed.".colourise
  end
when 'postpone-next'
  # Before we start asking, so we cannot wait for the exception.
  unless File.exist?(config.today_path)
    abort "<red>! File #{config.today_path.sub(ENV['HOME'], '~')} doesn't exist</red>".colourise
  end

  print "<bold>Why?</bold> ".colourise
  reason = STDIN.readline.chomp
  print "<bold>When do you want to review?</bold> Defaults to tomorrow. ".colourise
  review_at = STDIN.readline.chomp
  edit_next_task_when_no_task_active(config) do |next_task|
    review_at.empty? ? next_task.postpone!(reason) : next_task.postpone!(reason, review_at)
    puts "<bold>~</bold> <green>#{next_task.body}</green> has been postponed.".colourise
  end
when '+'
  task_list = parse_task_list(config)
  task_list['Later'] ||= Array.new
  task_list['Later'] << ARGV.join(' ')
  task_list.save(config.task_list_path)
when 'console', 'c'
  today = parse_today_list(config) if File.exist?(config.today_path)
  tasks = parse_task_list(config)  if File.exist?(config.task_list_path)
  require 'pry'; binding.pry
when 'tools'
  # TODO
  if ARGV.shift == 'workdays'
    start_date = Date.new(2018, 12, 1)
    end_date   = Date.new(2018, 12, 31)
    work_days = (start_date..end_date).reduce(0) do |sum, date|
      sum += 1 unless date.saturday? || date.sunday?; sum
    end
    puts "~ There are #{work_days} (without any bank holidays) in 2018."
    # TODO: Per-month breakdown.
  end
when 'review'
  today_list = parse_today_list(config) if File.exist?(config.today_path)
  pattern = ARGV.shift
  selected_time_frames = today_list.time_frames.select { |time_frame| time_frame.name.match(/#{pattern}/) }
  selected_time_frames.each do |time_frame|
    puts "<cyan>#{time_frame.name}</cyan>".colourise
    time_frame.tasks.each do |task|
      # Copied from bitbar.
      hash = {in_progress: 'yellow', completed: 'green', postponed: 'yellow'}
      hash.default_proc = Proc.new { 'bright_black' }
      colour = hash[task.status_x]

      print "<#{colour}>#{task}</#{colour}>".colourise
    end
  end

  puts "\n<bold>Total time:</bold> #{selected_time_frames.reduce(0) { |sum, time_frame| time_frame.actual_duration + sum }}".colourise
  puts "<bold>Cistyho casu:</bold> #{selected_time_frames.reduce(0) { |sum, time_frame| time_frame.duration_ + sum }}".colourise
when 'bitbar'
  require 'pomodoro/commands/bitbar'
  today_list = parse_today_list(config) if File.exist?(config.today_path)
  task_list  = parse_task_list(config)  if File.exist?(config.task_list_path)
  Pomodoro::Commands::BitBar.main(today_list, task_list)
when 'help', '-h', '--help'
  puts(DATA.read.colourise)
else
  abort(DATA.read.colourise)
end

__END__

<red.bold>:: Now task manager ::</red.bold>

now <green>edit</green>, now <green>e</green>
  <bright_black>now e</bright_black> Edit the today task file, creating it if it doesn't exist.
  <bright_black>now e <yellow>2</yellow></bright_black> Edit both the today task file and tasks (in a split screen).
  <bright_black>now e <yellow>tasks</yellow></bright_black> (or just <yellow>t</yellow>) Open the task file.
  <bright_black>now e <yellow>tomorrow</yellow></bright_black> Plan tomorrow.

now <magenta>start</magenta> <bright_black># Start a new task.</bright_black>
now <magenta>done</magenta> <bright_black># Complete the active task.</bright_black>
now <magenta>postpone</magenta> <bright_black># Postpone the active task.</bright_black>
now <magenta>move_on</magenta> <bright_black># Move on from the active task. Mark its end time, but don't set it as completed.</bright_black>

now <green>next</green> <bright_black># Print the next task.</bright_black>
now <green>active</green> <bright_black># Print the active task.</bright_black>

now <magenta>tick-off-next</magenta> <bright_black># ...</bright_black>
now <magenta>fail-next</magenta> <bright_black># ...</bright_black>
now <magenta>postpone-next</magenta> <bright_black># ...</bright_black>

now <magenta>review</magenta> pattern<bright_black># ...</bright_black>

now <red>+</red> [strings]<bright_black> # Add a task for later.</bright_black>

now <yellow>console</yellow>, now <yellow>c</yellow> <bright_black># Load the tasks and launch IRB.</bright_black>
now <yellow>bitbar</yellow> <bright_black># Print output for BitBar.</bright_black>
